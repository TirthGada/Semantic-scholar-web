// src/app/api/search/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { searchByEmbeddingVectorOnly, searchByKeywords } from '@/lib/opensearch';
import { spawnSync } from 'child_process';
import fs from 'fs';

export async function POST(request: NextRequest) {
  try {
    const { query, method, size = 100 } = await request.json();
    if (!query || !method) return NextResponse.json({ error: 'Query and method required' }, { status: 400 });

    console.log(`üîç ${method} search: "${query}"`);
    const startTime = Date.now();

    let papers;

    if (method === 'embedding') {
      // 1Ô∏è‚É£ Call Python to generate embedding
      const py = spawnSync('python3', ['scripts/embed_query.py'], {
        input: JSON.stringify([{ paper_id: 'QUERY', title: query, abstract: '' }]),
        encoding: 'utf-8'
      });

      if (py.error) throw py.error;
      if (py.status !== 0) throw new Error(`Python failed: ${py.stderr}`);

      // 2Ô∏è‚É£ Read embedding generated by Python
      const embeddingPath = 'query_embedding.json';
      if (!fs.existsSync(embeddingPath)) throw new Error('Python did not generate embedding');
      const embeddingData = JSON.parse(fs.readFileSync(embeddingPath, 'utf-8'));
      const embedding = embeddingData['QUERY'];

      papers = await searchByEmbeddingVectorOnly(embedding, size);
    } else {
      papers = await searchByKeywords(query, size);
    }

    const took = Date.now() - startTime;
    console.log(`‚úÖ Found ${papers.length} papers in ${took}ms`);

    return NextResponse.json({ papers, total: papers.length, took });
  } catch (error) {
    console.error('Search error:', error);
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    const errorStack = error instanceof Error ? error.stack : '';
    return NextResponse.json(
      { error: 'Search failed', details: errorMessage, stack: process.env.NODE_ENV === 'development' ? errorStack : undefined },
      { status: 500 }
    );
  }
}
